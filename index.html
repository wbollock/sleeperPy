<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>SleeperPy</title>
    <meta name="author" content="Will Bollock">
    <link rel="stylesheet" href="tiers/style.css">
    <link rel="stylesheet" href="css/normalize.css">
    <link rel="stylesheet" href="css/skeleton.css">
    <link rel="stylesheet" href="css/main.css">
    <link href="//fonts.googleapis.com/css?family=Raleway:400,300,600" rel="stylesheet" type="text/css">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
    input[type="text"] {
      color: black !important;
      background: white !important;
      width: 250px !important;
    }
    </style>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
    <script>
    const proxy = url => `http://localhost:5001/proxy?url=${encodeURIComponent(url)}`;
    // Helper: fetch and cache all NFL players
    let allPlayers = null;
    async function getAllPlayers() {
        if (allPlayers) return allPlayers;
        let res = await fetch(proxy('https://api.sleeper.app/v1/players/nfl'));
        allPlayers = await res.json();
        return allPlayers;
    }
    // Helper: fetch and cache Boris Chen tiers for all positions
    let borisTiers = {};
    const tierUrls = {
        QB: 'https://s3-us-west-1.amazonaws.com/fftiers/out/text_QB.txt',
        RB: 'https://s3-us-west-1.amazonaws.com/fftiers/out/text_RB-PPR.txt',
        WR: 'https://s3-us-west-1.amazonaws.com/fftiers/out/text_WR-PPR.txt',
        TE: 'https://s3-us-west-1.amazonaws.com/fftiers/out/text_TE-PPR.txt',
        K:  'https://s3-us-west-1.amazonaws.com/fftiers/out/text_K.txt',
        DST:'https://s3-us-west-1.amazonaws.com/fftiers/out/text_DST.txt',
    };
    async function getBorisTiers() {
        if (Object.keys(borisTiers).length) return borisTiers;
        for (let pos in tierUrls) {
            let txt = await fetch(proxy(tierUrls[pos])).then(r => r.text());
            borisTiers[pos] = txt.split('\n').filter(Boolean);
        }
        return borisTiers;
    }
    // Normalize names for matching
    function normalizeName(name) {
        return name.toLowerCase().replace(/\./g, '').replace(/ jr| sr| ii| iii| iv| v/g, '').replace(/[^a-z0-9 ]/g, '').replace(/\s+/g, ' ').trim();
    }
    // Find tier for a player name in a tier list
    function findTier(tierList, fullName) {
        let norm = normalizeName(fullName);
        for (let i = 0; i < tierList.length; ++i) {
            let names = tierList[i].replace(/^Tier \d+: /, '').split(',').map(x => normalizeName(x));
            if (names.includes(norm)) return i+1;
        }
        return null;
    }
    async function fetchTiers(event) {
        event.preventDefault();
        const username = document.getElementById('inputButton').value.trim();
        const output = document.getElementById('output');
        if (!username.match(/^[\w.-]+$/)) {
            output.innerHTML = '<span style="color:red">Please enter a valid username (letters, numbers, ".", "-", "_").</span>';
            return;
        }
        output.innerHTML = 'Loading...';
        try {
            // 1. Get user ID
            let res = await fetch(proxy(`https://api.sleeper.app/v1/user/${username}`));
            if (!res.ok) throw new Error('User not found');
            let user = await res.json();
            let userId = user.user_id;

            // 2. Get leagues
            const year = new Date().getFullYear();
            res = await fetch(proxy(`https://api.sleeper.app/v1/user/${userId}/leagues/nfl/${year}`));
            let leagues = await res.json();
            if (!leagues.length) throw new Error('No leagues found for this user.');

            // 3. Get all players and tiers
            let players = await getAllPlayers();
            let tiers = await getBorisTiers();

            // 4. Fetch all rosters and matchups in parallel
            let week = (new Date()).getWeek ? (new Date()).getWeek() : Math.ceil((((new Date()) - new Date(new Date().getFullYear(),0,1)) / 86400000 + new Date(new Date().getFullYear(),0,1).getDay()+1)/7);
            let rosterPromises = leagues.map(league => fetch(proxy(`https://api.sleeper.app/v1/league/${league.league_id}/rosters`)).then(r => r.json()));
            let matchupPromises = leagues.map(league => fetch(proxy(`https://api.sleeper.app/v1/league/${league.league_id}/matchups/${week}`)).then(r => r.json()));
            let allRosters = await Promise.all(rosterPromises);
            let allMatchups = await Promise.all(matchupPromises);

            // 5. For each league, process data
            let html = '';
            for (let i = 0; i < leagues.length; ++i) {
                let league = leagues[i];
                let leagueId = league.league_id;
                let leagueName = league.name;
                let scoring = league.scoring_settings.rec;
                let rosters = allRosters[i];
                let matchups = allMatchups[i];
                let userRoster = rosters.find(team => team.owner_id === userId);
                if (!userRoster) continue;
                let starters = userRoster.starters;
                let all = userRoster.players;
                // Find bench (all - starters)
                let bench = all.filter(pid => !starters.includes(pid));
                // Find opponent starters
                let myMatchup = matchups.find(m => m.roster_id === userRoster.roster_id);
                let oppMatchup = matchups.find(m => m.matchup_id === (myMatchup && myMatchup.matchup_id) && m.roster_id !== userRoster.roster_id);
                let oppStarters = oppMatchup ? oppMatchup.starters : [];
                // Map player IDs to info for starters, bench, opponent
                function getTierAndName(pid) {
                    let p = players[pid];
                    if (!p) return {name: pid, pos: '?', tier: null};
                    let pos = p.position;
                    let name;
                    let tier = null;
                    if (pos === 'DEF' || pos === 'DST') {
                        // Use full team name for DST, always use Boris DST tier list
                        name = TEAM_MAP[p.team] || p.team || 'Unknown';
                        let tierList = tiers['DST'];
                        if (tierList) tier = findTier(tierList, name);
                    } else {
                        name = (p.first_name || '') + ' ' + (p.last_name || '');
                        if (tiers[pos]) tier = findTier(tiers[pos], name);
                    }
                    return {name, pos, tier};
                }
                // Starters
                let starterRows = [];
                let starterTiers = [];
                let starterUnranked = [];
                for (let pid of starters) {
                    let {name, pos, tier} = getTierAndName(pid);
                    if (tier) {
                        starterRows.push(`<tr><td>${pos}</td><td>${name}</td><td>${tier}</td></tr>`);
                        starterTiers.push(tier);
                    } else {
                        starterUnranked.push(`<tr><td>?</td><td>${name}</td><td>Not Ranked</td></tr>`);
                    }
                }
                // Opponent average tier only
                let oppTiers = [];
                for (let pid of oppStarters) {
                    let {tier} = getTierAndName(pid);
                    if (tier) oppTiers.push(tier);
                }
                // Bench
                let benchRows = [];
                let benchUnranked = [];
                for (let pid of bench) {
                    let {name, pos, tier} = getTierAndName(pid);
                    if (tier) {
                        benchRows.push(`<tr><td>${pos}</td><td>${name}</td><td>${tier}</td></tr>`);
                    } else {
                        benchUnranked.push(`<tr><td>?</td><td>${name}</td><td>Not Ranked</td></tr>`);
                    }
                }
                // Average tier calculations (ignore unranked)
                function avg(arr) {
                    if (!arr.length) return '-';
                    let sum = arr.reduce((a,b) => a+b, 0);
                    return (sum/arr.length).toFixed(2);
                }
                let avgTier = avg(starterTiers);
                let avgOppTier = avg(oppTiers);
                // Win probability (simple: lower avg tier is better)
                let winProb = '-';
                let emoji = 'ü§ù';
                if (avgTier !== '-' && avgOppTier !== '-') {
                    let diff = avgOppTier - avgTier;
                    let prob = 50 + Math.max(-30, Math.min(30, diff * 10)); // cap at +/-30%
                    if (prob > 60) { emoji = 'üèÜ'; } else if (prob < 40) { emoji = 'üíÄ'; }
                    winProb = `${prob.toFixed(0)}% ${prob > 50 ? 'You' : 'Opponent'} ${emoji}`;
                }
                // Output
                html += `<h3>${leagueName} (PPR)</h3><table class="table-fill"><tr><th>Position</th><th>Player</th><th>Tier</th></tr>`;
                html += starterRows.join('');
                html += starterUnranked.join('');
                html += `<tr><td colspan="3" style="text-align:center;"><b>Average Tier: ${avgTier}</b></td></tr>`;
                html += `<tr><td colspan="3" style="text-align:center;"><b>Opponent Average Tier: ${avgOppTier}</b></td></tr>`;
                html += `<tr><td colspan="3" style="text-align:center;"><b>Win Probability: ${winProb}</b></td></tr>`;
                html += `<tr><th colspan="3" style="text-align:center;">Bench</th></tr>`;
                html += benchRows.join('');
                html += benchUnranked.join('');
                html += '</table><br>';
            }
            output.innerHTML = html;
        } catch (err) {
            output.innerHTML = `<span style='color:red'>Error: ${err.message}</span>`;
        }
    }
    // Add mapping for DST/DEF: Sleeper team abbrev to full name
    const TEAM_MAP = {
        ARI: 'Arizona Cardinals', ATL: 'Atlanta Falcons', BAL: 'Baltimore Ravens', BUF: 'Buffalo Bills',
        CAR: 'Carolina Panthers', CHI: 'Chicago Bears', CIN: 'Cincinnati Bengals', CLE: 'Cleveland Browns',
        DAL: 'Dallas Cowboys', DEN: 'Denver Broncos', DET: 'Detroit Lions', GB: 'Green Bay Packers',
        HOU: 'Houston Texans', IND: 'Indianapolis Colts', JAX: 'Jacksonville Jaguars', KC: 'Kansas City Chiefs',
        LV: 'Las Vegas Raiders', LAC: 'Los Angeles Chargers', LAR: 'Los Angeles Rams', MIA: 'Miami Dolphins',
        MIN: 'Minnesota Vikings', NE: 'New England Patriots', NO: 'New Orleans Saints', NYG: 'New York Giants',
        NYJ: 'New York Jets', PHI: 'Philadelphia Eagles', PIT: 'Pittsburgh Steelers', SEA: 'Seattle Seahawks',
        SF: 'San Francisco 49ers', TB: 'Tampa Bay Buccaneers', TEN: 'Tennessee Titans', WAS: 'Washington Commanders'
    };
    </script>
</head>
<body>
<div class="container">
    <div class="row centerinput">
        <h1 class="homepageHeader"><a href="https://wboll.dev/sleeperPy">SleeperPy</a></h1>
        <h5 id="infoText" style="text-align:left;">Displays your team's <a href="http://www.borischen.co/">Boris Chen</a> tiers across all Sleeper leagues.</h5>
        <form id="userform" onsubmit="fetchTiers(event)">
            <input id="inputButton" type="text" name="name" required placeholder="Sleeper Username">
            <br>
            <input id="generateTiers" type="submit" value="Show My Tiers">
        </form>
        <div id="output" style="margin-top:20px;"></div>
        <br><br>
    </div>
</div>
<div class="container">
    <div class="row centerinput">
        <footer>
            <ul>
                <li>In the "Tiers" column, lower is better.</li>
                <li><a href="https://github.com/wbollock/sleeperPy">GitHub Repo</a> | 
                <a href="http://www.borischen.co/">Source of Tiers</a> | 
                <a href="https://codepen.io/alassetter/pen/cyrfB">CSS Table Styling</a> | 
                <a href="http://getskeleton.com/">General Styling</a>
                </li>
            </ul>
        </footer>
    </div>
</div>
</body>
</html>
